<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EQ Matching Game</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, sans-serif; }
    .container { min-height: 100vh; background: linear-gradient(to bottom right, #0f172a, #1e293b); padding: 2rem; }
    .card { max-width: 1200px; margin: 0 auto; background: #1e293b; border-radius: 0.5rem; padding: 2rem; box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25); border: 1px solid #334155; }
    h1 { font-size: 1.875rem; font-weight: bold; color: white; margin-bottom: 0.5rem; }
    .subtitle { color: #cbd5e1; margin-bottom: 1.5rem; }
    button { padding: 0.75rem 1.5rem; border-radius: 0.5rem; font-weight: 500; border: none; cursor: pointer; transition: all 0.2s; }
    .btn-blue { background: #2563eb; color: white; } .btn-blue:hover { background: #1d4ed8; }
    .btn-amber { background: #d97706; color: white; } .btn-amber:hover { background: #b45309; }
    .btn-slate { background: #475569; color: white; } .btn-slate:hover { background: #334155; }
    .btn-green { background: #16a34a; color: white; } .btn-green:hover { background: #15803d; }
    .btn-red { background: #dc2626; color: white; } .btn-red:hover { background: #b91c1c; }
    .controls { display: flex; gap: 1rem; margin-bottom: 1.5rem; }
    .canvas-container { background: #0f172a; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem; }
    canvas { width: 100%; cursor: crosshair; }
    .legend { margin-top: 1rem; display: flex; gap: 1rem; align-items: center; }
    .legend-item { display: flex; align-items: center; gap: 0.5rem; color: #cbd5e1; font-size: 0.875rem; }
    .legend-box { width: 1rem; height: 1rem; border-radius: 0.25rem; }
    .grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-bottom: 1.5rem; }
    .band { background: #475569; border-radius: 0.5rem; padding: 1rem; cursor: pointer; transition: all 0.2s; }
    .band.selected { box-shadow: 0 0 0 2px #f59e0b; }
    .band h3 { color: white; font-size: 1.125rem; margin-bottom: 0.75rem; }
    .input-group { margin-bottom: 0.75rem; }
    .input-group label { display: block; color: #94a3b8; font-size: 0.75rem; margin-bottom: 0.25rem; }
    .input-group input { width: 100%; background: #1e293b; color: white; padding: 0.5rem 0.75rem; border-radius: 0.25rem; border: none; font-size: 0.875rem; }
    .input-group input[type="range"] { padding: 0; }
    .score-card { background: #14532d; border: 1px solid #16a34a; border-radius: 0.5rem; padding: 1.5rem; margin-top: 1.5rem; }
    .score-card h2 { color: white; font-size: 1.5rem; font-weight: bold; margin-bottom: 0.5rem; }
    .score-card p { color: #86efac; }
    .file-input { display: flex; align-items: center; gap: 0.75rem; padding: 1rem 1.5rem; background: #475569; color: white; border-radius: 0.5rem; font-weight: 500; cursor: pointer; width: fit-content; margin-bottom: 1.5rem; transition: all 0.2s; }
    .file-input:hover { background: #334155; }
    .file-input input { display: none; }
    .success-text { color: #4ade80; font-size: 0.875rem; margin-top: 0.5rem; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const EQMatchingGame = () => {
      const [isPlaying, setIsPlaying] = useState(false);
      const [hasSubmitted, setHasSubmitted] = useState(false);
      const [score, setScore] = useState(null);
      const [audioFile, setAudioFile] = useState(null);
      const [audioBuffer, setAudioBuffer] = useState(null);
      const [selectedBand, setSelectedBand] = useState(0);
      const [isDragging, setIsDragging] = useState(false);
      const [bypassFilters, setBypassFilters] = useState(false);
      const canvasRef = useRef(null);
      
      const audioContextRef = useRef(null);
      const sourceRef = useRef(null);
      const filtersRef = useRef([]);
      const gainNodeRef = useRef(null);
      
      const [targetEQ, setTargetEQ] = useState([]);
      
      const [userEQ, setUserEQ] = useState([
        { freq: 120, gain: 0, q: 1.0 },
        { freq: 800, gain: 0, q: 1.0 },
        { freq: 3200, gain: 0, q: 1.0 }
      ]);

      useEffect(() => {
        const generateRandomEQ = () => {
          const freqRanges = [
            { min: 80, max: 250 },
            { min: 400, max: 2000 },
            { min: 2500, max: 8000 }
          ];
          
          return freqRanges.map(range => ({
            freq: Math.round(Math.random() * (range.max - range.min) + range.min),
            gain: Math.round((Math.random() * 24 - 12) * 2) / 2,
            q: Math.round((Math.random() * 2 + 0.5) * 10) / 10
          }));
        };
        
        setTargetEQ(generateRandomEQ());
      }, []);

      useEffect(() => {
        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
        return () => {
          if (audioContextRef.current) {
            audioContextRef.current.close();
          }
        };
      }, []);

      useEffect(() => {
        drawEQCurve();
      }, [userEQ, selectedBand, hasSubmitted, targetEQ]);

      const handleFileUpload = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        setAudioFile(file);
        const arrayBuffer = await file.arrayBuffer();
        const decodedBuffer = await audioContextRef.current.decodeAudioData(arrayBuffer);
        setAudioBuffer(decodedBuffer);
        
        if (isPlaying) {
          if (sourceRef.current) {
            sourceRef.current.stop();
            sourceRef.current = null;
          }
          setIsPlaying(false);
        }
      };

      const createAudioSource = (useBypass) => {
        const shouldBypass = useBypass !== undefined ? useBypass : bypassFilters;
        
        if (!audioBuffer || targetEQ.length === 0) return null;
        
        const ctx = audioContextRef.current;
        const source = ctx.createBufferSource();
        source.buffer = audioBuffer;
        source.loop = true;
        
        gainNodeRef.current = ctx.createGain();
        gainNodeRef.current.gain.value = 0.5;
        
        if (shouldBypass) {
          source.connect(gainNodeRef.current);
          gainNodeRef.current.connect(ctx.destination);
        } else {
          filtersRef.current = targetEQ.map((band) => {
            const filter = ctx.createBiquadFilter();
            filter.type = 'peaking';
            filter.frequency.value = band.freq;
            filter.Q.value = band.q;
            filter.gain.value = band.gain;
            return filter;
          });
          
          let currentNode = source;
          filtersRef.current.forEach(filter => {
            currentNode.connect(filter);
            currentNode = filter;
          });
          currentNode.connect(gainNodeRef.current);
          gainNodeRef.current.connect(ctx.destination);
        }
        
        source.start();
        return source;
      };

      const togglePlayback = () => {
        if (!audioBuffer) return;
        if (targetEQ.length === 0) return;
        
        if (!isPlaying) {
          if (audioContextRef.current.state === 'suspended') {
            audioContextRef.current.resume();
          }
          sourceRef.current = createAudioSource();
          setIsPlaying(true);
        } else {
          if (sourceRef.current) {
            sourceRef.current.stop();
            sourceRef.current = null;
          }
          setIsPlaying(false);
        }
      };

      const toggleBypass = () => {
        const newBypassState = !bypassFilters;
        setBypassFilters(newBypassState);
        
        if (isPlaying) {
          if (sourceRef.current) {
            sourceRef.current.stop();
            sourceRef.current = null;
          }
          
          setTimeout(() => {
            if (audioContextRef.current.state === 'suspended') {
              audioContextRef.current.resume();
            }
            sourceRef.current = createAudioSource(newBypassState);
            if (!sourceRef.current) {
              setIsPlaying(false);
            }
          }, 50);
        }
      };

      const updateBand = (index, updates) => {
        setUserEQ(prev => {
          const newEQ = [...prev];
          newEQ[index] = { ...newEQ[index], ...updates };
          return newEQ;
        });
      };

      const freqToX = (freq, width) => {
        const minFreq = Math.log10(20);
        const maxFreq = Math.log10(20000);
        const logFreq = Math.log10(freq);
        return ((logFreq - minFreq) / (maxFreq - minFreq)) * width;
      };

      const xToFreq = (x, width) => {
        const minFreq = Math.log10(20);
        const maxFreq = Math.log10(20000);
        const logFreq = minFreq + (x / width) * (maxFreq - minFreq);
        return Math.pow(10, logFreq);
      };

      const gainToY = (gain, height) => {
        const minGain = -12;
        const maxGain = 12;
        return height - ((gain - minGain) / (maxGain - minGain)) * height;
      };

      const yToGain = (y, height) => {
        const minGain = -12;
        const maxGain = 12;
        return maxGain - (y / height) * (maxGain - minGain);
      };

      const calculateEQResponse = (freq, bands) => {
        let totalGainLinear = 1;
        
        bands.forEach(band => {
          const sampleRate = 48000;
          const w0 = 2 * Math.PI * band.freq / sampleRate;
          const A = Math.pow(10, band.gain / 40);
          const alpha = Math.sin(w0) / (2 * band.q);
          
          const b0 = 1 + alpha * A;
          const b1 = -2 * Math.cos(w0);
          const b2 = 1 - alpha * A;
          const a0 = 1 + alpha / A;
          const a1 = -2 * Math.cos(w0);
          const a2 = 1 - alpha / A;
          
          const nb0 = b0 / a0;
          const nb1 = b1 / a0;
          const nb2 = b2 / a0;
          const na1 = a1 / a0;
          const na2 = a2 / a0;
          
          const w = 2 * Math.PI * freq / sampleRate;
          
          const numReal = nb0 + nb1 * Math.cos(w) + nb2 * Math.cos(2 * w);
          const numImag = -nb1 * Math.sin(w) - nb2 * Math.sin(2 * w);
          
          const denReal = 1 + na1 * Math.cos(w) + na2 * Math.cos(2 * w);
          const denImag = -na1 * Math.sin(w) - na2 * Math.sin(2 * w);
          
          const denominator = denReal * denReal + denImag * denImag;
          const hReal = (numReal * denReal + numImag * denImag) / denominator;
          const hImag = (numImag * denReal - numReal * denImag) / denominator;
          
          const magnitude = Math.sqrt(hReal * hReal + hImag * hImag);
          totalGainLinear *= magnitude;
        });
        
        return 20 * Math.log10(totalGainLinear);
      };

      const drawEQCurve = () => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        ctx.clearRect(0, 0, width, height);
        
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 1;
        
        for (let gain = -12; gain <= 12; gain += 3) {
          const y = gainToY(gain, height);
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
          
          if (gain === 0) {
            ctx.strokeStyle = '#475569';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 1;
          }
        }
        
        const frequencies = [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000];
        frequencies.forEach(freq => {
          const x = freqToX(freq, width);
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        });
        
        ctx.fillStyle = '#94a3b8';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        
        frequencies.forEach(freq => {
          const x = freqToX(freq, width);
          const label = freq >= 1000 ? (freq / 1000) + 'k' : freq.toString();
          ctx.fillText(label, x, height - 5);
        });
        
        ctx.textAlign = 'right';
        for (let gain = -12; gain <= 12; gain += 6) {
          const y = gainToY(gain, height);
          ctx.fillText((gain > 0 ? '+' : '') + gain + 'dB', width - 5, y - 5);
        }
        
        if (hasSubmitted && targetEQ.length > 0) {
          ctx.strokeStyle = '#22c55e';
          ctx.lineWidth = 2;
          ctx.globalAlpha = 0.5;
          ctx.beginPath();
          for (let x = 0; x < width; x += 2) {
            const freq = xToFreq(x, width);
            const gain = calculateEQResponse(freq, targetEQ);
            const y = gainToY(gain, height);
            if (x === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
        
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 3;
        ctx.beginPath();
        for (let x = 0; x < width; x += 2) {
          const freq = xToFreq(x, width);
          const gain = calculateEQResponse(freq, userEQ);
          const y = gainToY(gain, height);
          if (x === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        
        userEQ.forEach((band, index) => {
          const x = freqToX(band.freq, width);
          const y = gainToY(band.gain, canvas.height);
          
          ctx.fillStyle = index === selectedBand ? '#f59e0b' : '#3b82f6';
          ctx.beginPath();
          ctx.arc(x, y, 8, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.strokeStyle = '#1e293b';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          if (!hasSubmitted) {
            ctx.fillStyle = 'white';
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText((index + 1).toString(), x, y + 4);
          }
        });
      };

      const handleCanvasMouseDown = (e) => {
        if (hasSubmitted) return;
        
        const canvas = canvasRef.current;
        const rect = canvas.getBoundingClientRect();
        
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        
        for (let i = 0; i < userEQ.length; i++) {
          const handleX = freqToX(userEQ[i].freq, canvas.width);
          const handleY = gainToY(userEQ[i].gain, canvas.height);
          const dist = Math.sqrt(Math.pow(x - handleX, 2) + Math.pow(y - handleY, 2));
          
          if (dist < 20) {
            setSelectedBand(i);
            setIsDragging(true);
            return;
          }
        }
      };

      const handleCanvasMouseMove = (e) => {
        if (!isDragging || hasSubmitted) return;
        
        const canvas = canvasRef.current;
        const rect = canvas.getBoundingClientRect();
        
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        const x = Math.max(0, Math.min(canvas.width, (e.clientX - rect.left) * scaleX));
        const y = Math.max(0, Math.min(canvas.height, (e.clientY - rect.top) * scaleY));
        
        const freq = Math.round(xToFreq(x, canvas.width));
        const gain = Math.round(yToGain(y, canvas.height) * 2) / 2;
        
        updateBand(selectedBand, {
          freq: Math.max(20, Math.min(20000, freq)),
          gain: Math.max(-12, Math.min(12, gain))
        });
      };

      const handleCanvasMouseUp = () => {
        setIsDragging(false);
      };

      const calculateScore = () => {
        let totalError = 0;
        userEQ.forEach((band, i) => {
          const freqErrorRatio = Math.abs(Math.log10(band.freq) - Math.log10(targetEQ[i].freq)) / Math.log10(20000 / 20);
          const freqError = freqErrorRatio * 25;
          const gainError = Math.abs(band.gain - targetEQ[i].gain) * 4;
          const qError = Math.abs(band.q - targetEQ[i].q) * 3;
          
          totalError += freqError + gainError + qError;
        });
        
        const maxError = 200;
        const score = Math.max(0, Math.round((1 - totalError / maxError) * 100));
        return score;
      };

      const handleSubmit = () => {
        const finalScore = calculateScore();
        setScore(finalScore);
        setHasSubmitted(true);
      };

      const resetGame = () => {
        setUserEQ([
          { freq: 120, gain: 0, q: 1.0 },
          { freq: 800, gain: 0, q: 1.0 },
          { freq: 3200, gain: 0, q: 1.0 }
        ]);
        setHasSubmitted(false);
        setScore(null);
        setSelectedBand(0);
        
        const wasPlaying = isPlaying;
        if (isPlaying) {
          if (sourceRef.current) {
            sourceRef.current.stop();
            sourceRef.current = null;
          }
          setIsPlaying(false);
        }
        
        const freqRanges = [
          { min: 80, max: 250 },
          { min: 400, max: 2000 },
          { min: 2500, max: 8000 }
        ];
        
        const newTargetEQ = freqRanges.map(range => ({
          freq: Math.round(Math.random() * (range.max - range.min) + range.min),
          gain: Math.round((Math.random() * 24 - 12) * 2) / 2,
          q: Math.round((Math.random() * 2 + 0.5) * 10) / 10
        }));
        
        setTargetEQ(newTargetEQ);
        
        if (wasPlaying && audioBuffer) {
          setTimeout(() => {
            if (audioContextRef.current.state === 'suspended') {
              audioContextRef.current.resume();
            }
            sourceRef.current = createAudioSource();
            if (sourceRef.current) {
              setIsPlaying(true);
            }
          }, 100);
        }
      };

      return (
        <div className="container">
          <div className="card">
            <h1>Parametric EQ Matching Game</h1>
            <p className="subtitle">Upload audio, listen to the EQ'd version, drag points to match what you hear</p>

            <label className="file-input">
              <span>üìÅ {audioFile ? audioFile.name : 'Upload Audio File'}</span>
              <input type="file" accept="audio/*" onChange={handleFileUpload} />
            </label>
            {audioFile && <p className="success-text">‚úì Ready</p>}

            <div className="controls">
              <button onClick={togglePlayback} className="btn-blue">
                {isPlaying ? '‚è∏ Pause' : '‚ñ∂ Play'}
              </button>
              <button onClick={toggleBypass} className={bypassFilters ? 'btn-amber' : 'btn-slate'}>
                {bypassFilters ? 'Bypassed' : 'Bypass'}
              </button>
              <button onClick={resetGame} className="btn-slate">
                üîÑ Reset
              </button>
            </div>

            <div className="canvas-container">
              <canvas
                ref={canvasRef}
                width={900}
                height={400}
                onMouseDown={handleCanvasMouseDown}
                onMouseMove={handleCanvasMouseMove}
                onMouseUp={handleCanvasMouseUp}
                onMouseLeave={handleCanvasMouseUp}
              />
              <div className="legend">
                <div className="legend-item">
                  <div className="legend-box" style={{background: '#2563eb'}}></div>
                  <span>Your EQ</span>
                </div>
                {hasSubmitted && (
                  <div className="legend-item">
                    <div className="legend-box" style={{background: '#22c55e', opacity: 0.5}}></div>
                    <span>Target</span>
                  </div>
                )}
              </div>
            </div>

            <div className="grid">
              {userEQ.map((band, index) => (
                <div
                  key={index}
                  onClick={() => setSelectedBand(index)}
                  className={'band' + (selectedBand === index ? ' selected' : '')}
                >
                  <h3>Band {index + 1}</h3>
                  <div className="input-group">
                    <label>Frequency (Hz)</label>
                    <input
                      type="number"
                      value={Math.round(band.freq)}
                      onChange={(e) => updateBand(index, { freq: parseFloat(e.target.value) || 20 })}
                      disabled={hasSubmitted}
                    />
                  </div>
                  <div className="input-group">
                    <label>Gain (dB)</label>
                    <input
                      type="number"
                      step="0.5"
                      value={band.gain}
                      onChange={(e) => updateBand(index, { gain: parseFloat(e.target.value) || 0 })}
                      disabled={hasSubmitted}
                    />
                  </div>
                  <div className="input-group">
                    <label>Q: {band.q.toFixed(1)}</label>
                    <input
                      type="range"
                      min="0.1"
                      max="10"
                      step="0.1"
                      value={band.q}
                      onChange={(e) => updateBand(index, { q: parseFloat(e.target.value) })}
                      disabled={hasSubmitted}
                    />
                  </div>
                </div>
              ))}
            </div>

            {!hasSubmitted && (
              <button onClick={handleSubmit} className="btn-green" style={{width: '100%', padding: '1rem'}}>
                ‚úì Submit & Check Score
              </button>
            )}

            {hasSubmitted && (
              <div className="score-card">
                <h2>Score: {score}/100</h2>
                <p>
                  {score >= 90 ? 'Good job, no promotion!' :
                   score >= 70 ? 'Progress!' :
                   score >= 50 ? 'Could be worse' :
                   'Keep practicing!'}
                </p>
              </div>
            )}
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<EQMatchingGame />);
  </script>
</body>
</html>
