<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EQ Matching Game</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
 import React, { useState, useEffect, useRef } from 'react';
import { Play, Pause, RotateCcw, CheckCircle, Upload } from 'lucide-react';

const EQMatchingGame = () => {
  const [isPlaying, setIsPlaying] = useState(false);
  const [hasSubmitted, setHasSubmitted] = useState(false);
  const [score, setScore] = useState(null);
  const [audioFile, setAudioFile] = useState(null);
  const [audioBuffer, setAudioBuffer] = useState(null);
  const [selectedBand, setSelectedBand] = useState(0);
  const [isDragging, setIsDragging] = useState(false);
  const [bypassFilters, setBypassFilters] = useState(false);
  const canvasRef = useRef(null);
  
  const audioContextRef = useRef(null);
  const sourceRef = useRef(null);
  const filtersRef = useRef([]);
  const gainNodeRef = useRef(null);
  
  const [targetEQ, setTargetEQ] = useState([]);
  
  const [userEQ, setUserEQ] = useState([
    { freq: 120, gain: 0, q: 1.0 },
    { freq: 800, gain: 0, q: 1.0 },
    { freq: 3200, gain: 0, q: 1.0 }
  ]);

  useEffect(() => {
    const generateRandomEQ = () => {
      const freqRanges = [
        { min: 80, max: 250 },
        { min: 400, max: 2000 },
        { min: 2500, max: 8000 }
      ];
      
      return freqRanges.map(range => ({
        freq: Math.round(Math.random() * (range.max - range.min) + range.min),
        gain: Math.round((Math.random() * 24 - 12) * 2) / 2,
        q: Math.round((Math.random() * 2 + 0.5) * 10) / 10
      }));
    };
    
    setTargetEQ(generateRandomEQ());
  }, []);

  useEffect(() => {
    audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
    return () => {
      if (audioContextRef.current) {
        audioContextRef.current.close();
      }
    };
  }, []);

  useEffect(() => {
    drawEQCurve();
  }, [userEQ, selectedBand, hasSubmitted, targetEQ]);

  const handleFileUpload = async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    setAudioFile(file);
    const arrayBuffer = await file.arrayBuffer();
    const decodedBuffer = await audioContextRef.current.decodeAudioData(arrayBuffer);
    setAudioBuffer(decodedBuffer);
    
    if (isPlaying) {
      if (sourceRef.current) {
        sourceRef.current.stop();
        sourceRef.current = null;
      }
      setIsPlaying(false);
    }
  };

  const createAudioSource = (useBypass) => {
    const shouldBypass = useBypass !== undefined ? useBypass : bypassFilters;
    
    if (!audioBuffer || targetEQ.length === 0) return null;
    
    const ctx = audioContextRef.current;
    const source = ctx.createBufferSource();
    source.buffer = audioBuffer;
    source.loop = true;
    
    gainNodeRef.current = ctx.createGain();
    gainNodeRef.current.gain.value = 0.5;
    
    if (shouldBypass) {
      source.connect(gainNodeRef.current);
      gainNodeRef.current.connect(ctx.destination);
    } else {
      filtersRef.current = targetEQ.map((band) => {
        const filter = ctx.createBiquadFilter();
        filter.type = 'peaking';
        filter.frequency.value = band.freq;
        filter.Q.value = band.q;
        filter.gain.value = band.gain;
        return filter;
      });
      
      let currentNode = source;
      filtersRef.current.forEach(filter => {
        currentNode.connect(filter);
        currentNode = filter;
      });
      currentNode.connect(gainNodeRef.current);
      gainNodeRef.current.connect(ctx.destination);
    }
    
    source.start();
    return source;
  };

  const togglePlayback = () => {
    if (!audioBuffer) return;
    if (targetEQ.length === 0) return;
    
    if (!isPlaying) {
      if (audioContextRef.current.state === 'suspended') {
        audioContextRef.current.resume();
      }
      sourceRef.current = createAudioSource();
      setIsPlaying(true);
    } else {
      if (sourceRef.current) {
        sourceRef.current.stop();
        sourceRef.current = null;
      }
      setIsPlaying(false);
    }
  };

  const toggleBypass = () => {
    const newBypassState = !bypassFilters;
    setBypassFilters(newBypassState);
    
    if (isPlaying) {
      if (sourceRef.current) {
        sourceRef.current.stop();
        sourceRef.current = null;
      }
      
      setTimeout(() => {
        if (audioContextRef.current.state === 'suspended') {
          audioContextRef.current.resume();
        }
        sourceRef.current = createAudioSource(newBypassState);
        if (!sourceRef.current) {
          setIsPlaying(false);
        }
      }, 50);
    }
  };

  const updateBand = (index, updates) => {
    setUserEQ(prev => {
      const newEQ = [...prev];
      newEQ[index] = { ...newEQ[index], ...updates };
      return newEQ;
    });
  };

  const freqToX = (freq, width) => {
    const minFreq = Math.log10(20);
    const maxFreq = Math.log10(20000);
    const logFreq = Math.log10(freq);
    return ((logFreq - minFreq) / (maxFreq - minFreq)) * width;
  };

  const xToFreq = (x, width) => {
    const minFreq = Math.log10(20);
    const maxFreq = Math.log10(20000);
    const logFreq = minFreq + (x / width) * (maxFreq - minFreq);
    return Math.pow(10, logFreq);
  };

  const gainToY = (gain, height) => {
    const minGain = -12;
    const maxGain = 12;
    return height - ((gain - minGain) / (maxGain - minGain)) * height;
  };

  const yToGain = (y, height) => {
    const minGain = -12;
    const maxGain = 12;
    return maxGain - (y / height) * (maxGain - minGain);
  };

  const calculateEQResponse = (freq, bands) => {
    let totalGainLinear = 1;
    
    bands.forEach(band => {
      const sampleRate = 48000;
      const w0 = 2 * Math.PI * band.freq / sampleRate;
      const A = Math.pow(10, band.gain / 40);
      const alpha = Math.sin(w0) / (2 * band.q);
      
      const b0 = 1 + alpha * A;
      const b1 = -2 * Math.cos(w0);
      const b2 = 1 - alpha * A;
      const a0 = 1 + alpha / A;
      const a1 = -2 * Math.cos(w0);
      const a2 = 1 - alpha / A;
      
      const nb0 = b0 / a0;
      const nb1 = b1 / a0;
      const nb2 = b2 / a0;
      const na1 = a1 / a0;
      const na2 = a2 / a0;
      
      const w = 2 * Math.PI * freq / sampleRate;
      
      const numReal = nb0 + nb1 * Math.cos(w) + nb2 * Math.cos(2 * w);
      const numImag = -nb1 * Math.sin(w) - nb2 * Math.sin(2 * w);
      
      const denReal = 1 + na1 * Math.cos(w) + na2 * Math.cos(2 * w);
      const denImag = -na1 * Math.sin(w) - na2 * Math.sin(2 * w);
      
      const denominator = denReal * denReal + denImag * denImag;
      const hReal = (numReal * denReal + numImag * denImag) / denominator;
      const hImag = (numImag * denReal - numReal * denImag) / denominator;
      
      const magnitude = Math.sqrt(hReal * hReal + hImag * hImag);
      totalGainLinear *= magnitude;
    });
    
    return 20 * Math.log10(totalGainLinear);
  };

  const drawEQCurve = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    ctx.clearRect(0, 0, width, height);
    
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    
    for (let gain = -12; gain <= 12; gain += 3) {
      const y = gainToY(gain, height);
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(width, y);
      ctx.stroke();
      
      if (gain === 0) {
        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 1;
      }
    }
    
    const frequencies = [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000];
    frequencies.forEach(freq => {
      const x = freqToX(freq, width);
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.stroke();
    });
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'center';
    
    frequencies.forEach(freq => {
      const x = freqToX(freq, width);
      const label = freq >= 1000 ? (freq / 1000) + 'k' : freq.toString();
      ctx.fillText(label, x, height - 5);
    });
    
    ctx.textAlign = 'right';
    for (let gain = -12; gain <= 12; gain += 6) {
      const y = gainToY(gain, height);
      ctx.fillText((gain > 0 ? '+' : '') + gain + 'dB', width - 5, y - 5);
    }
    
    if (hasSubmitted && targetEQ.length > 0) {
      ctx.strokeStyle = '#22c55e';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      for (let x = 0; x < width; x += 2) {
        const freq = xToFreq(x, width);
        const gain = calculateEQResponse(freq, targetEQ);
        const y = gainToY(gain, height);
        if (x === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 3;
    ctx.beginPath();
    for (let x = 0; x < width; x += 2) {
      const freq = xToFreq(x, width);
      const gain = calculateEQResponse(freq, userEQ);
      const y = gainToY(gain, height);
      if (x === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
    
    userEQ.forEach((band, index) => {
      const x = freqToX(band.freq, width);
      const y = gainToY(band.gain, canvas.height);
      
      ctx.fillStyle = index === selectedBand ? '#f59e0b' : '#3b82f6';
      ctx.beginPath();
      ctx.arc(x, y, 8, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.strokeStyle = '#1e293b';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      if (!hasSubmitted) {
        ctx.fillStyle = 'white';
        ctx.font = 'bold 10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText((index + 1).toString(), x, y + 4);
      }
    });
  };

  const handleCanvasMouseDown = (e) => {
    if (hasSubmitted) return;
    
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    
    for (let i = 0; i < userEQ.length; i++) {
      const handleX = freqToX(userEQ[i].freq, canvas.width);
      const handleY = gainToY(userEQ[i].gain, canvas.height);
      const dist = Math.sqrt(Math.pow(x - handleX, 2) + Math.pow(y - handleY, 2));
      
      if (dist < 20) {
        setSelectedBand(i);
        setIsDragging(true);
        return;
      }
    }
  };

  const handleCanvasMouseMove = (e) => {
    if (!isDragging || hasSubmitted) return;
    
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    const x = Math.max(0, Math.min(canvas.width, (e.clientX - rect.left) * scaleX));
    const y = Math.max(0, Math.min(canvas.height, (e.clientY - rect.top) * scaleY));
    
    const freq = Math.round(xToFreq(x, canvas.width));
    const gain = Math.round(yToGain(y, canvas.height) * 2) / 2;
    
    updateBand(selectedBand, {
      freq: Math.max(20, Math.min(20000, freq)),
      gain: Math.max(-12, Math.min(12, gain))
    });
  };

  const handleCanvasMouseUp = () => {
    setIsDragging(false);
  };

  const calculateScore = () => {
    let totalError = 0;
    userEQ.forEach((band, i) => {
      const freqErrorRatio = Math.abs(Math.log10(band.freq) - Math.log10(targetEQ[i].freq)) / Math.log10(20000 / 20);
      const freqError = freqErrorRatio * 25;
      const gainError = Math.abs(band.gain - targetEQ[i].gain) * 4;
      const qError = Math.abs(band.q - targetEQ[i].q) * 3;
      
      totalError += freqError + gainError + qError;
    });
    
    const maxError = 200;
    const score = Math.max(0, Math.round((1 - totalError / maxError) * 100));
    return score;
  };

  const handleSubmit = () => {
    const finalScore = calculateScore();
    setScore(finalScore);
    setHasSubmitted(true);
  };

  const resetGame = () => {
    setUserEQ([
      { freq: 120, gain: 0, q: 1.0 },
      { freq: 800, gain: 0, q: 1.0 },
      { freq: 3200, gain: 0, q: 1.0 }
    ]);
    setHasSubmitted(false);
    setScore(null);
    setSelectedBand(0);
    
    const wasPlaying = isPlaying;
    if (isPlaying) {
      if (sourceRef.current) {
        sourceRef.current.stop();
        sourceRef.current = null;
      }
      setIsPlaying(false);
    }
    
    const freqRanges = [
      { min: 80, max: 250 },
      { min: 400, max: 2000 },
      { min: 2500, max: 8000 }
    ];
    
    const newTargetEQ = freqRanges.map(range => ({
      freq: Math.round(Math.random() * (range.max - range.min) + range.min),
      gain: Math.round((Math.random() * 24 - 12) * 2) / 2,
      q: Math.round((Math.random() * 2 + 0.5) * 10) / 10
    }));
    
    setTargetEQ(newTargetEQ);
    
    if (wasPlaying && audioBuffer) {
      setTimeout(() => {
        if (audioContextRef.current.state === 'suspended') {
          audioContextRef.current.resume();
        }
        sourceRef.current = createAudioSource();
        if (sourceRef.current) {
          setIsPlaying(true);
        }
      }, 100);
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 to-slate-800 p-8">
      <div className="max-w-6xl mx-auto">
        <div className="bg-slate-800 rounded-lg shadow-2xl p-8 border border-slate-700">
          <h1 className="text-3xl font-bold text-white mb-2">Parametric EQ Matching Game</h1>
          <p className="text-slate-300 mb-6">
            Upload audio, listen to the EQ'd version, drag points to match what you hear
          </p>

          <div className="mb-6">
            <label className="flex items-center gap-3 px-6 py-4 bg-slate-700 hover:bg-slate-600 text-white rounded-lg font-medium transition-colors cursor-pointer w-fit">
              <Upload size={20} />
              <span>{audioFile ? audioFile.name : 'Upload Audio File'}</span>
              <input
                type="file"
                accept="audio/*"
                onChange={handleFileUpload}
                className="hidden"
              />
            </label>
            {audioFile && (
              <p className="text-green-400 text-sm mt-2">✓ Ready</p>
            )}
          </div>

          <div className="flex gap-4 mb-6">
            <button
              onClick={togglePlayback}
              className="flex items-center gap-2 px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium transition-colors"
            >
              {isPlaying ? <Pause size={20} /> : <Play size={20} />}
              {isPlaying ? 'Pause' : 'Play'}
            </button>
            <button
              onClick={toggleBypass}
              className={'flex items-center gap-2 px-6 py-3 text-white rounded-lg font-medium transition-colors ' + (bypassFilters ? 'bg-amber-600 hover:bg-amber-700' : 'bg-slate-700 hover:bg-slate-600')}
            >
              {bypassFilters ? 'Bypassed' : 'Bypass'}
            </button>
            <button
              onClick={resetGame}
              className="flex items-center gap-2 px-6 py-3 bg-slate-700 hover:bg-slate-600 text-white rounded-lg font-medium transition-colors"
            >
              <RotateCcw size={20} />
              Reset
            </button>
          </div>

          <div className="bg-slate-900 rounded-lg p-4 mb-6">
            <canvas
              ref={canvasRef}
              width={900}
              height={400}
              className="w-full cursor-crosshair"
              onMouseDown={handleCanvasMouseDown}
              onMouseMove={handleCanvasMouseMove}
              onMouseUp={handleCanvasMouseUp}
              onMouseLeave={handleCanvasMouseUp}
            />
            <div className="mt-4 flex gap-4 items-center">
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 bg-blue-600 rounded"></div>
                <span className="text-slate-300 text-sm">Your EQ</span>
              </div>
              {hasSubmitted && (
                <div className="flex items-center gap-2">
                  <div className="w-4 h-4 bg-green-500 rounded opacity-50"></div>
                  <span className="text-slate-300 text-sm">Target</span>
                </div>
              )}
            </div>
          </div>

          <div className="grid grid-cols-3 gap-4 mb-6">
            {userEQ.map((band, index) => (
              <div
                key={index}
                onClick={() => setSelectedBand(index)}
                className={'bg-slate-700 rounded-lg p-4 cursor-pointer transition-all ' + (selectedBand === index ? 'ring-2 ring-amber-500' : '')}
              >
                <h3 className="text-lg font-medium text-white mb-3">Band {index + 1}</h3>
                <div className="space-y-3">
                  <div>
                    <label className="block text-xs text-slate-400 mb-1">Frequency (Hz)</label>
                    <input
                      type="number"
                      value={Math.round(band.freq)}
                      onChange={(e) => updateBand(index, { freq: parseFloat(e.target.value) || 20 })}
                      disabled={hasSubmitted}
                      className="w-full bg-slate-800 text-white px-3 py-2 rounded text-sm"
                    />
                  </div>
                  <div>
                    <label className="block text-xs text-slate-400 mb-1">Gain (dB)</label>
                    <input
                      type="number"
                      step="0.5"
                      value={band.gain}
                      onChange={(e) => updateBand(index, { gain: parseFloat(e.target.value) || 0 })}
                      disabled={hasSubmitted}
                      className="w-full bg-slate-800 text-white px-3 py-2 rounded text-sm"
                    />
                  </div>
                  <div>
                    <label className="block text-xs text-slate-400 mb-1">Q: {band.q.toFixed(1)}</label>
                    <input
                      type="range"
                      min="0.1"
                      max="10"
                      step="0.1"
                      value={band.q}
                      onChange={(e) => updateBand(index, { q: parseFloat(e.target.value) })}
                      disabled={hasSubmitted}
                      className="w-full"
                    />
                  </div>
                </div>
              </div>
            ))}
          </div>

          {!hasSubmitted && (
            <button
              onClick={handleSubmit}
              className="w-full flex items-center justify-center gap-2 px-6 py-4 bg-green-600 hover:bg-green-700 text-white rounded-lg font-medium transition-colors text-lg"
            >
              <CheckCircle size={24} />
              Submit & Check Score
            </button>
          )}

          {hasSubmitted && (
            <div className="mt-6">
              <div className="bg-green-900 border border-green-700 rounded-lg p-6">
                <h2 className="text-2xl font-bold text-white mb-2">Score: {score}/100</h2>
                <p className="text-green-200">
                  {score >= 90 ? 'Excellent!' :
                   score >= 70 ? 'Great job!' :
                   score >= 50 ? 'Good effort!' :
                   'Keep practicing!'}
                </p>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default EQMatchingGame;
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<EQMatchingGame />);
  </script>
</body>
</html>